# -*- coding: utf-8 -*-
"""Utility_Functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aoqqegCDFdfiIV3VYIant0TviRhT1Gct

#### Load Packages
"""

import os
import sys
import numpy as np
import pandas as pd
import torch
import h5py
import matplotlib.pyplot as plt
import matplotlib.font_manager
from matplotlib import rcParams
import seaborn as sns
from scipy import stats
from scipy.stats import mannwhitneyu

"""#### Dataframe Utility Functions

*   This class contains functions used for creating sub-dataframes and data arrays from the original dataframe based on defined criteria.
*  The returned dataframes and data arrays are used as inputs to statistical tests.
"""

def guide_df(control_lab, per_lab, df):
  """Given guide labels and input dataframe, subsets input dataframe to contain only values under specified guides.
  In general, used to subset the dataframe to contain control's and one perturbation's population, can be used to compare any two guides' population.

  Args:
  control_lab: Labels associated with control population or the first guide's population. Does not need to be exact, may contain only part of the guide string.
  per_lab: Labels associated with perturbation population or the second guide's population. Does not need to be exact, may contain only part of the guide string.
  df: Dataframe that contains both labels under "guides" column.

  Returns:
  subset_df: Dataframe that contains a subset of the input dataframe to contain only values specified by input guides.
  """

  guide_counts = df["guide"].value_counts()

  control_guides = guide_counts.filter(like=str(control_lab)).index # filters exact guide names that contain the input guide label string
  control_idx = df['guide'].isin(control_guides) # finds indices corresponding to exact guide names
  control_df = df.loc[control_idx, :] # subsets dataframe

  per_guides = guide_counts.filter(like=str(per_lab)).index
  per_idx = df['guide'].isin(per_guides)
  per_df = df.loc[per_idx, :]

  frames = [control_df, per_df]
  subset_df = pd.concat(frames) # concatenates two guides

  return subset_df

def data_array(lab, foci, df):
  """Given guide label, foci and input dataframe, subsets input dataframe to contain only values under specified guide and foci.

  Args:
  lab: Guide label of the guide of interest. Does not need to be exact, may contain only part of the guide string.
  foci: Foci of interest.
  df: Dataframe that contains both the guide label under "guides" column and the foci column.

  Returns:
  lab_foc_df: Dataframe that contains a subset of the input dataframe to contain only values specified by the input guide and the input foci. Has only guide and foci columnns.
  lab_foc_arr: Data array of the subset dataframe. Has dimensions 1 x length of guide column (number of cells under guide)
  """

  guide_counts = df["guide"].value_counts()

  lab_guides = guide_counts.filter(like=str(lab)).index # filters exact guide names that contain the input guide label string
  lab_idx = df['guide'].isin(lab_guides) # finds indices corresponding to exact guide names
  lab_df = df.loc[lab_idx, :] # subsets dataframe

  lab_foc_df = lab_df[str(foci)]
  lab_foc_arr = lab_df[str(foci)].values

  return lab_foc_df, lab_foc_arr

def binary(value, lab):
  """Give value and guide label, returns binary 0-1 with 1 indicating that the value given is in specified guide label.
  This function is often applied to the "guides" column of a subset dataframe to binarize control vs perturbation.
  """

  if str(lab) in value:
      return 1
  else:
      return 0

def get_func(df):
  """Given input dataframe, finds the Function and ClinVar values of the associated perturbation. Assumes the input dataframe to only contain the control and the perturbation of interest.
  The input dataframe should have the "guides" column binarized 0-1 with 0 indicating control and 1 indicating perturbation.

  Args:
  df: Dataframe that contains a 0-1 binary value under "guides" column indicating control vs perturbation; and contains the "Function" and "ClinVar" columns.

  Returns:
  func_lab: Value of the "Function" column at perturbation guide; indicates perturbation function (ie. missense, nonsense, splice-donor ... etc)
  clin_lab: Value of the "ClinVar" column at perturbation guide; indicates perturbation Clinical Effects (ie. PL/P, BL/B, VUS ... etc)
  """

  filt_df = df[df["guide"] == 1] # filters the dataframe to contain only the perturbation information ("guide" == 1)

  func_lab = filt_df["Function"].iloc[0]
  clin_lab = filt_df["ClinVar"].iloc[0]

  return func_lab, clin_lab

"""#### Statistical Test Functions

*   This class contains functions used for statistical tests on foci-specific control vs perturbation.
*   In general, the functions are integrated into a loop that iterates through a list of perturbations across a list of foci and the returned test statistics and p-values are stored into dictionaries in the analysis notebook.
"""

def MWU(foci, df): # MWU test measures the difference between central tendencies of two samples.
  """
  Given specific foci and input dataframe, computes the Mann-Whitney-U test statistic and p-value of control vs perturbation populations.
  The control vs perturbation populations are differentiated by the "guide" column containning binarized 0-1 values indicating control vs perturbation.
  The input dataframe is assumed to contain only the control and perturbation guide associated information and a binarized "guide" column.

  Args:
  foci: Foci of interest.
  df: Dataframe that contains only the control and perturbation guide associated information and a binarized "guide" column.

  Returns:
  stat: Mann-Whitney-U test statistic.
  p: Mann-Whitney-U test p-value.
  """

  rv0 = df[df["guide"] == 0] # Define data array of control population's foci expression
  rv0 = rv0[foci].values
  rv1 = df[df["guide"] == 1] # Define data array of perturbation population's foci expression
  rv1 = rv1[foci].values
  stat, p = mannwhitneyu(rv0, rv1) # Conducts the MWU test
  return stat, p

def KS(foci, df):  # Two sample KS test measures the difference between distribution shapes of two samples.
  """
  Given specific foci and input dataframe, computes the two-sample Kolmogorov-Smirnov test statistic and p-value of control vs perturbation populations.
  The control vs perturbation populations are differentiated by the "guide" column containing binarized 0-1 values indicating control vs perturbation.

  Args:
  foci: Foci of interest.
  df: Dataframe that contains only the control and perturbation guide associated information and a binarized "guide" column.

  Returns:
  stat: Kolmogorov-Smirnov test statistic.
  p: Kolmogorov-Smirnov test p-value.
  """

  rv0 = df[df["guide"] == 0] # Define data array of control population's foci expression
  rv0 = rv0[foci].values
  rv1 = df[df["guide"] == 1] # Define data array of perturbation population's foci expression
  rv1 = rv1[foci].values
  stat, p = stats.kstest(rv0, rv1) # Conducts the KS test
  return stat, p

def WS(foci, df):
  """
  Given specific foci and input dataframe, computes the Wasserstein distance between the control and perturbation populations' distributions.
  The control vs perturbation populations are differentiated by the "guide" column containing binarized 0-1 values indicating control vs perturbation.

  Args:
  foci: Foci of interest.
  df: Dataframe that contains only the control and perturbation guide associated information and a binarized "guide" column.

  Returns:
  dist: Wasserstein distance between the distributions of the control and perturbation populations.
  """

  rv0 = df[df["guide"] == 0] # Define data array of control population's foci expression
  rv0 = rv0[foci].values
  rv1 = df[df["guide"] == 1] # Define data array of perturbation population's foci expression
  rv1 = rv1[foci].values
  dist = stats.wasserstein_distance(rv0, rv1) # Computes the Wasserstein Distance
  return dist

"""#### Visualization Functions


*   This class of functions is used for foci expression visualization and can be used for visualizing cell cycle's effects on foci expression.


"""

def get_df(guide, df):
  """Given guide label and input dataframe, subsets input dataframe to contain only values under specified guide.

  Args:
  guide: Guide label of interest. Does not need to be exact, may contain only part of the guide string.
  df: Dataframe that contains both the input guide label under "guides" column.

  Returns:
  subset_df: Dataframe that contains a subset of the input dataframe to contain only values specified by input guide.
  """

  guide_counts = df["guide"].value_counts()
  lab_guides = guide_counts.filter(like=str(guide)).index
  lab_idx = df['guide'].isin(lab_guides)
  lab_df = df.loc[lab_idx, :]
  return lab_df

def cc_binary(string):
  """Binarize the input string.

  Returns: 0 if string is 'G1' and 1 if string is 'G2/S'
  """

  if string == "G1":
      return 0
  else:
      return 1

def get_ccprp(df):
  """Given input dataframe, compute the proportion of cells in G1 and in G2/S.
  Args:
  df: Dataframe that contains the "cell_cycle" column. This input dataframe is usually the output dataframe of the
  get_df function to compute the G1 and G2/S proportion of a specified guide.

  Returns:
  G1: G1 cells proportion of the input dataframe.
  G2: G2/S cells proportion of the input dataframe.
  """

  G2 = df["cell_cycle"].sum()/len(df["cell_cycle"])
  G1 = 1-G2
  return G1,G2

def get_array(foci, df):
  """Given foci and input dataframe, defines the Non-targeting, AAVS1 and Perturbation foci expresion arrays.

  Args:
  foci: Specific foci of interest.
  df: Expression dataframe that contains the "type" column.

  Returns:
  NT_arr: Array of foci expression of all Non-targeting guides in the input dataframe.
  AAVS_arr: Array of foci expression of all AAVS1 guides in the input dataframe.
  Per_arr: Array of foci expression of all Perturbation guides in the input dataframe.
  """

  NT_df = df[df["type"] == "NT"]
  NT_arr = NT_df[str(foci)].values

  AAVS_df = df[df["type"] == "AAVS"]
  AAVS_arr = AAVS_df[str(foci)].values

  Per_df = df[df["type"] == "Per"]
  Per_arr = Per_df[str(foci)].values

  return NT_arr, AAVS_arr, Per_arr

def find_keys_with_foci(foci, dict):
  """Given foci and input dictionary, find keys with associated foci. The input dictionary is gene_foci_dict that contains significant KS test results.

  Args:
  foci: Specific foci of interest.
  dict: Input dictionary containning KS test results.

  Returns:
  keys_with_foci: List of keys (guides) with values that contain the foci. ie. Guides that are significant on the foci of interest.
  """
  keys_with_foci = []
  for key, value in dict.items():
      if any(foci in sublist for sublist in value):
          keys_with_foci.append(key)
  return keys_with_foci